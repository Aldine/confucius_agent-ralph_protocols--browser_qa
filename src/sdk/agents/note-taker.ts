/**
 * Confucius SDK - Note-Taker Agent
 * 
 * The Note-Taker agent distills execution trajectories into
 * persistent, structured Markdown notes.
 * 
 * Implements the Scribe functionality for long-term memory.
 * 
 * @see https://arxiv.org/abs/2512.10398v5 Section 2.3.2 (Note-Taking Agent)
 */

import type { Message, Note, Logger, ExecutionResult } from '../types.js';

/**
 * LLM interface for the NoteTaker.
 */
export interface NoteTakerLLM {
  chat(systemPrompt: string, userMessage: string): Promise<string>;
}

/**
 * NoteTakerAgent - Trajectory â†’ Markdown distillation.
 * 
 * After each session, the Note-Taker:
 * 1. Analyzes the execution trajectory
 * 2. Extracts key insights, patterns, and solutions
 * 3. Creates/updates structured Markdown notes
 * 4. Records hindsight notes for failures
 */
export class NoteTakerAgent {
  private logger: Logger;
  private llm?: NoteTakerLLM;

  constructor(logger: Logger, llm?: NoteTakerLLM) {
    this.logger = logger;
    this.llm = llm;
  }

  /**
   * Set the LLM client (can be set after construction).
   */
  setLLM(llm: NoteTakerLLM): void {
    this.llm = llm;
  }

  /**
   * Generate a structured session summary using the LLM.
   * 
   * @param trace - The execution trace (messages from the session)
   * @param result - The final execution result
   * @returns Markdown-formatted session summary
   */
  async generateSessionSummary(
    trace: Message[],
    result: ExecutionResult
  ): Promise<string> {
    this.logger.info('[NoteTaker] Generating session summary...', {
      traceMessages: trace.length,
      success: result.success,
    });

    if (!this.llm) {
      this.logger.warn('[NoteTaker] No LLM configured, using fallback summary');
      return this.createFallbackSummary(trace, result);
    }

    const systemPrompt = `You are the Scribe. Analyze the following execution trace.

Produce a structured Markdown log containing:

1. **User Goal** - What the user wanted to accomplish
2. **Final Outcome** - Success or Failure, with brief explanation
3. **Key Strategy Used** - The approach the agent took to solve the problem
4. **Errors & Fixes** - Any errors encountered and how they were resolved (if applicable)

Keep each section concise (2-3 sentences max). Use bullet points where appropriate.
Format the output as clean Markdown that can be saved directly to a file.`;

    const traceContent = this.formatTraceForAnalysis(trace);
    const outcomeStatus = result.success ? 'SUCCESS' : 'FAILURE';
    
    const userMessage = `## Execution Trace

${traceContent}

## Final Result
Status: ${outcomeStatus}
Output: ${result.output}
${result.error ? `Error: ${result.error.message}` : ''}

Please generate the structured session summary.`;

    try {
      const summary = await this.llm.chat(systemPrompt, userMessage);
      
      this.logger.info('[NoteTaker] Session summary generated', {
        summaryLength: summary.length,
      });

      // Wrap with metadata header
      const timestamp = new Date().toISOString();
      return `---
generated: ${timestamp}
status: ${outcomeStatus}
messages: ${trace.length}
---

${summary}

---
*Generated by Confucius NoteTaker Agent*`;
    } catch (error) {
      this.logger.error('[NoteTaker] LLM summary generation failed', {
        error: error instanceof Error ? error.message : String(error),
      });
      return this.createFallbackSummary(trace, result);
    }
  }

  /**
   * Distill a session trajectory into notes.
   * 
   * @param sessionId - The session identifier
   * @param messages - The full message history
   * @param existingNotes - Previously existing notes
   * @returns Array of new or updated notes
   */
  async distill(
    sessionId: string,
    messages: Message[],
    existingNotes: Note[] = []
  ): Promise<Note[]> {
    this.logger.info('[NoteTaker] Distilling session', {
      sessionId,
      messageCount: messages.length,
      existingNotes: existingNotes.length,
    });

    const notes: Note[] = [];

    // Create a session summary note
    const summaryNote = this.createSessionSummaryNote(sessionId, messages);
    notes.push(summaryNote);

    // Identify any failures and create hindsight notes
    const failureNote = this.createHindsightNote(sessionId, messages);
    if (failureNote) {
      notes.push(failureNote);
    }

    this.logger.info('[NoteTaker] Notes distilled', {
      sessionId,
      noteCount: notes.length,
    });

    return notes;
  }

  /**
   * Format execution trace for LLM analysis.
   */
  private formatTraceForAnalysis(messages: Message[]): string {
    return messages.map((m, i) => {
      const role = m.role.toUpperCase();
      const tool = m.toolName ? ` [${m.toolName}]` : '';
      // Truncate very long messages
      const content = m.content.length > 800 
        ? m.content.substring(0, 800) + '...[truncated]'
        : m.content;
      return `[${i + 1}] ${role}${tool}:\n${content}`;
    }).join('\n\n---\n\n');
  }

  /**
   * Create a fallback summary when LLM is not available.
   */
  private createFallbackSummary(trace: Message[], result: ExecutionResult): string {
    const userMessages = trace.filter(m => m.role === 'user');
    const toolMessages = trace.filter(m => m.role === 'tool');
    const toolsUsed = [...new Set(toolMessages.map(m => m.toolName).filter(Boolean))];
    
    const userGoal = userMessages[0]?.content.substring(0, 200) || 'Unknown goal';
    const timestamp = new Date().toISOString();
    
    return `---
generated: ${timestamp}
status: ${result.success ? 'SUCCESS' : 'FAILURE'}
messages: ${trace.length}
---

# Session Summary

## 1. User Goal
${userGoal}

## 2. Final Outcome
**${result.success ? 'Success' : 'Failure'}**: ${result.output.substring(0, 300)}

## 3. Key Strategy Used
- Tools invoked: ${toolsUsed.join(', ') || 'none'}
- Total interactions: ${trace.length} messages

## 4. Errors & Fixes
${result.error ? `- Error: ${result.error.message}` : '- No errors encountered'}

---
*Generated by Confucius NoteTaker Agent (fallback mode)*`;
  }

  /**
   * Create a basic session summary note (for distill method).
   */
  private createSessionSummaryNote(sessionId: string, messages: Message[]): Note {
    const userMessages = messages.filter(m => m.role === 'user');
    const toolCalls = messages.filter(m => m.role === 'tool');
    
    const task = userMessages[0]?.content.substring(0, 100) ?? 'Unknown task';

    return {
      path: `sessions/${sessionId}/summary.md`,
      content: `# Session Summary: ${sessionId}

## Task
${task}...

## Statistics
- Messages: ${messages.length}
- Tool calls: ${toolCalls.length}
- Started: ${messages[0]?.timestamp?.toISOString() ?? 'Unknown'}

---
_Auto-generated by NoteTakerAgent_
`,
      updatedAt: new Date(),
      tags: ['session', 'summary', sessionId],
      isHindsight: false,
    };
  }

  /**
   * Create a hindsight note if there were failures.
   */
  private createHindsightNote(
    sessionId: string,
    messages: Message[]
  ): Note | null {
    // Look for error patterns in tool results
    const errors = messages.filter(
      m => m.role === 'tool' && 
           (m.content.includes('Error') || 
            m.content.includes('failed') ||
            m.content.includes('success: false'))
    );

    if (errors.length === 0) {
      return null;
    }

    return {
      path: `sessions/${sessionId}/hindsight.md`,
      content: `# Hindsight Notes: ${sessionId}

## Failures Encountered
${errors.length} error(s) occurred during this session.

## Sample Errors
\`\`\`
${errors.slice(0, 3).map(e => e.content.substring(0, 200)).join('\n---\n')}
\`\`\`

---
_Auto-generated by NoteTakerAgent (hindsight)_
`,
      updatedAt: new Date(),
      tags: ['session', 'hindsight', 'errors', sessionId],
      isHindsight: true,
    };
  }
}

/**
 * Create a new Note-Taker agent instance.
 */
export function createNoteTakerAgent(logger: Logger, llm?: NoteTakerLLM): NoteTakerAgent {
  return new NoteTakerAgent(logger, llm);
}
